type UserTx = 
 record {
   createdAt: Time;
   dest: opt nat;
   fee: float64;
   id: nat32;
   marketId: nat32;
   price: float64;
   recv: float64;
   sent: float64;
   src: opt nat;
 };
type UserStable = 
 record {
   bio: text;
   comments: vec CommentStable;
   createdAt: Time;
   discord: text;
   followees: vec Followee;
   followers: vec Follower;
   handle: text;
   id: text;
   lastSeenAt: Time;
   markets: vec UserMarket;
   modifiedAt: Time;
   picture: text;
   posts: vec Post;
   twitter: text;
   txs: vec UserTx;
 };
type UserMarket = 
 record {
   author: bool;
   balances: vec float64;
   brierScores: vec BrierScore;
   collateralType: CollateralType;
   createdAt: Time;
   labels: vec text;
   marketId: nat32;
   modifiedAt: Time;
   redeemed: bool;
   shares: float64;
   spent: float64;
   title: text;
 };
type UserError = 
 variant {
   callerIsAnon;
   commentIsEmpty;
   descriptionMissing;
   endDateOld;
   endDateOlderThanStartDate;
   imageMissing;
   marketMissing;
   marketNotOpen;
   minimalAmountIsOne;
   newtonFailed;
   notEnoughBalance;
   notEnoughLiquidity: float64;
   optionsMissing;
   profileNotCreated;
   startDateOld;
   titleMissing;
   userAlreadyExist;
 };
type Time = int;
type Result_2 = 
 variant {
   err: MarketError;
   ok: CommentStable;
 };
type Result_1 = 
 variant {
   err: MarketError;
   ok: MarketStable;
 };
type Result = 
 variant {
   err: UserError;
   ok: UserStable;
 };
type Post = 
 record {
   author: text;
   comments: vec CommentStable;
   content: text;
   createdAt: Time;
   id: nat32;
   likes: vec Like;
 };
type MarketState = 
 variant {
   approved;
   closed;
   invalid;
   open;
   pending;
   resolved: nat;
 };
type MarketStable = 
 record {
   author: text;
   bettors: vec text;
   category: MarketCategory;
   collateralType: CollateralType;
   comments: vec CommentStable;
   createdAt: Time;
   description: text;
   endDate: Time;
   histPrices: vec HistPoint;
   id: nat32;
   imageUrl: text;
   images: vec text;
   k: float64;
   labels: vec text;
   liquidity: float64;
   modifiedAt: Time;
   probabilities: vec float64;
   providers: vec text;
   reserves: vec float64;
   startDate: Time;
   state: MarketState;
   title: text;
   totalShares: float64;
   volume: float64;
 };
type MarketInitData = 
 record {
   author: text;
   category: MarketCategory;
   collateralType: CollateralType;
   description: text;
   endDate: Time;
   imageUrl: text;
   images: vec text;
   labels: vec text;
   liquidity: float64;
   nextId: nat32;
   probabilities: vec float64;
   startDate: Time;
   title: text;
 };
type MarketError = 
 variant {
   callerIsAnon;
   commentIsEmpty;
   descriptionMissing;
   endDateOld;
   endDateOlderThanStartDate;
   imageMissing;
   marketMissing;
   marketNotOpen;
   minimalAmountIsOne;
   newtonFailed;
   notEnoughBalance;
   notEnoughLiquidity: float64;
   optionsMissing;
   profileNotCreated;
   startDateOld;
   titleMissing;
   userAlreadyExist;
 };
type MarketCategory = 
 variant {
   business;
   crypto;
   dfinity;
   entertainment;
   financial;
   politics;
   science;
   seers;
   sports;
 };
type Like = 
 record {
   author: text;
   createdAt: Time;
   stars: nat32;
 };
type ICP = record {e8s: nat64;};
type HistPoint = 
 record {
   createdAt: Time;
   liquidity: float64;
   probabilities: vec float64;
 };
type Follower = 
 record {
   createdAt: Time;
   user: text;
 };
type Followee = 
 record {
   createdAt: Time;
   user: text;
 };
type CommentStable = 
 record {
   author: text;
   content: text;
   createdAt: Time;
   id: nat32;
   likes: vec Like;
   modifiedAt: Time;
 };
type CollateralType = 
 variant {
   cycles;
   icp;
   seers;
 };
type BrierScore = 
 record {
   createdAt: Time;
   score: float64;
 };
type AccountIdentifier = blob;
service : {
  addCommentToMarket: (nat32, text) -> (Result_2);
  approveMarket: (nat32) -> ();
  callerAccount: () -> (AccountIdentifier);
  canisterAccount: () -> (text) query;
  canisterFloat: () -> (ICP);
  createMarket: (MarketInitData) -> (Result_1);
  createUser: (text) -> (Result);
  getUserStable: (text) -> (opt UserStable) query;
  readAllMarkets: () -> (vec MarketStable) query;
  readAllUsers: () -> (vec UserStable) query;
  readMarket: (nat32) -> (opt MarketStable) query;
  resolveMarket: (nat32, nat) -> (bool);
  setUpdating: (bool) -> () oneway;
}
