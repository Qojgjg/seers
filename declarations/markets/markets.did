type UserResult3 = 
 record {
   expSeerBalance: Balance;
   handle: text;
   id: UserId;
   markets: vec UserMarket3;
   seerBalance: Balance;
 };
type UserMarket3 = 
 record {
   balances: vec Balance;
   labels: vec text;
   marketId: MarketId;
   marketTitle: Title;
   shares: Shares;
   used: bool;
 };
type UserId = text;
type Url = text;
type TradeError = 
 variant {
   callerIsAnon;
   marketClosed;
   marketMissing;
   newtonFailed;
   notEnoughBalance;
   userNotCreated;
 };
type Title = text;
type Time = int;
type Shares = int;
type Result_4 = 
 variant {
   err: AddCommentError;
   ok: Comment;
 };
type Result_3 = 
 variant {
   err: CreateMarketError;
   ok: MarketResult;
 };
type Result_2 = 
 variant {
   err: CreateUserError;
   ok: UserResult3;
 };
type Result_1 = 
 variant {
   err: RefreshUserError;
   ok: UserResult3;
 };
type Result = 
 variant {
   err: TradeError;
   ok: Balance;
 };
type RefreshUserError = 
 variant {
   callerIsAnon;
   userNotCreated;
 };
type Probability = float64;
type MarketState = 
 variant {
   closed;
   open;
   pending;
   resolved: nat;
 };
type MarketResult = 
 record {
   author: Author;
   blockTimestampLast: Time;
   comments: vec Comment;
   description: Description;
   endDate: Time;
   id: MarketId;
   imageUrl: Url;
   images: vec text;
   k: Balance;
   labels: vec text;
   liquidity: Balance;
   probabilities: vec Probability;
   providers: vec text;
   reserves: vec Balance;
   startDate: Time;
   state: MarketState;
   title: Title;
   totalShares: Shares;
   volume: Balance;
 };
type MarketInitData = 
 record {
   description: Description;
   endDate: Time;
   imageUrl: Url;
   images: vec text;
   labels: vec text;
   liquidity: Balance;
   title: Title;
 };
type MarketId = nat32;
type Market = 
 service {
   addCommentToMarket: (MarketId, text) -> (Result_4);
   approveMarket: (MarketId) -> ();
   backup: () -> ();
   buyOption: (MarketId, Balance, nat, bool) -> (Result);
   createMarket: (MarketInitData) -> (Result_3);
   createUserResult3: (text) -> (Result_2);
   deleteAllMarkets: () -> ();
   deleteMarket: (MarketId) -> (opt MarketResult);
   editMarketImage: (MarketId, text) -> (bool);
   editMarketProbs: (MarketId, vec Balance) -> (bool);
   getUserResult3: (UserId) -> (opt UserResult3) query;
   importMarkets: (vec MarketResult) -> () oneway;
   importUsers: (vec UserResult3) -> () oneway;
   readAllMarkets: () -> (vec MarketResult) query;
   readAllOpenMarkets: () -> (vec MarketResult) query;
   readAllPendingMarkets: () -> (vec MarketResult) query;
   readAllUsers3: () -> (vec UserResult3) query;
   readMarket: (MarketId) -> (opt MarketResult) query;
   readNewUsers: () -> (vec record {
                              UserId;
                              UserResult3;
                            });
   refreshUser: () -> (Result_1);
   resolveMarket: (MarketId, nat) -> (bool);
   restore: () -> ();
   sellOption: (MarketId, Balance, nat, bool) -> (Result);
   setUpdating: (bool) -> () oneway;
   tip: (UserId, Balance) -> (opt Balance);
 };
type Description = text;
type CreateUserError = 
 variant {
   userExist;
   userIsAnon;
 };
type CreateMarketError = 
 variant {
   callerIsAnon;
   descriptionMissing;
   endDateOld: Time;
   imageMissing;
   notEnoughLiquidity: Balance;
   optionsMissing;
   titleMissing;
   userNotCreated;
 };
type Comment = 
 record {
   author: text;
   content: text;
 };
type Balance = float64;
type Author = text;
type AddCommentError = 
 variant {
   commentIsEmpty;
   marketMissing;
   userIsAnon;
   userNotCreated;
 };
service : () -> Market
