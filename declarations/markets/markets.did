type UserTx = 
 record {
   createdAt: Time;
   dest: opt nat;
   fee: float64;
   id: nat32;
   marketId: nat32;
   price: float64;
   recv: float64;
   sent: float64;
   src: opt nat;
 };
type UserStable = 
 record {
   age: nat;
   balances: Balance;
   bio: text;
   city: text;
   comments: vec CommentStable;
   cover: text;
   createdAt: Time;
   depositAddrs: vec DepositAddr;
   discord: text;
   expBalances: Balance;
   feed: vec FeedItem;
   followees: vec Followee;
   followers: vec Follower;
   handle: text;
   id: text;
   lastSeenAt: Time;
   markets: vec UserMarket;
   modifiedAt: Time;
   name: text;
   picture: text;
   postData: vec PostStable;
   postRoots: vec nat32;
   twitter: text;
   txs: vec UserTx;
   website: text;
 };
type UserMarket = 
 record {
   author: bool;
   balances: vec float64;
   brierScores: vec BrierScore;
   collateralType: CollateralType;
   createdAt: Time;
   labels: vec text;
   marketId: nat32;
   modifiedAt: Time;
   redeemed: bool;
   shares: float64;
   spent: float64;
   title: text;
 };
type UserInitData = 
 record {
   age: nat;
   bio: text;
   city: text;
   cover: text;
   discord: text;
   handle: text;
   id: text;
   name: text;
   picture: text;
   twitter: text;
   website: text;
 };
type UserError = 
 variant {
   callerIsAnon;
   commentIsEmpty;
   descriptionMissing;
   endDateOld;
   endDateOlderThanStartDate;
   imageMissing;
   marketMissing;
   marketNotOpen;
   minimalAmountIsOne;
   newtonFailed;
   notEnoughBalance;
   notEnoughLiquidity: float64;
   optionsMissing;
   profileNotCreated;
   startDateOld;
   titleMissing;
   userAlreadyExist;
 };
type UserData = 
 record {
   handle: text;
   name: text;
   picture: text;
   "principal": text;
 };
type Time = int;
type Result_5 = 
 variant {
   err: MarketError;
   ok: CommentStable;
 };
type Result_4 = 
 variant {
   err: MarketError;
   ok: MarketStable;
 };
type Result_3 = 
 variant {
   err: UserError;
   ok: UserStable;
 };
type Result_2 = 
 variant {
   err: MarketError;
   ok: float64;
 };
type Result_1 = 
 variant {
   err: MarketError;
   ok;
 };
type Result = 
 variant {
   err: UserError;
   ok;
 };
type PostStable = 
 record {
   author: UserData;
   content: text;
   createdAt: Time;
   id: nat32;
   likes: vec Like;
   parent: nat32;
   replies: vec nat32;
 };
type MarketState = 
 variant {
   any;
   approved;
   closed;
   invalid;
   open;
   pending;
   resolved: nat;
 };
type MarketStable = 
 record {
   author: text;
   bettors: vec text;
   category: MarketCategory;
   collateralType: CollateralType;
   comments: vec CommentStable;
   createdAt: Time;
   description: text;
   endDate: Time;
   forecasts: vec Forecast;
   histPrices: vec HistPoint;
   id: nat32;
   imageUrl: text;
   images: vec text;
   k: float64;
   labels: vec text;
   liquidity: float64;
   modifiedAt: Time;
   probabilities: vec float64;
   providers: vec text;
   reserves: vec float64;
   startDate: Time;
   state: MarketState;
   title: text;
   totalShares: float64;
   volume: float64;
 };
type MarketInitData = 
 record {
   author: text;
   category: MarketCategory;
   collateralType: CollateralType;
   description: text;
   endDate: Time;
   id: nat32;
   imageUrl: text;
   images: vec text;
   labels: vec text;
   liquidity: float64;
   probabilities: vec float64;
   startDate: Time;
   title: text;
 };
type MarketError = 
 variant {
   callerIsAnon;
   commentIsEmpty;
   descriptionMissing;
   endDateOld;
   endDateOlderThanStartDate;
   imageMissing;
   marketMissing;
   marketNotOpen;
   minimalAmountIsOne;
   newtonFailed;
   notEnoughBalance;
   notEnoughLiquidity: float64;
   optionsMissing;
   profileNotCreated;
   startDateOld;
   titleMissing;
   userAlreadyExist;
 };
type MarketCategory = 
 variant {
   any;
   business;
   crypto;
   dfinity;
   entertainment;
   financial;
   politics;
   science;
   seers;
   self;
   sports;
 };
type Market = 
 service {
   addCommentToMarket: (nat32, text) -> (Result_5);
   buyOutcome: (nat32, float64, nat, bool) -> (Result_2);
   callerAccount: () -> (AccountIdentifier);
   canisterAccount: () -> (text) query;
   canisterFloat: () -> (ICP);
   createMarket: (MarketInitData) -> (Result_4);
   createUser: (UserInitData) -> (Result_3);
   getFeed: () -> (vec PostStable) query;
   getUserStable: (text) -> (opt UserStable) query;
   readAllMarkets: (MarketCategory, MarketState) -> (vec MarketStable) query;
   readAllUsers: () -> (vec UserStable) query;
   readMarket: (nat32) -> (opt MarketStable) query;
   readUserData: (vec text) -> (vec UserData) query;
   refreshUser: () -> (Result_3);
   resolveMarket: (nat32, nat) -> (bool);
   sellOutcome: (nat32, float64, nat, bool) -> (Result_2);
   setMarketState: (nat32, MarketState) -> (bool);
   setUpdating: (bool) -> () oneway;
   submitForecast: (nat32, Forecast) -> (Result_1);
   submitPost: (text) -> (Result);
 };
type Like = 
 record {
   author: text;
   createdAt: Time;
   stars: nat32;
 };
type ICP = record {e8s: nat64;};
type HistPoint = 
 record {
   createdAt: Time;
   liquidity: float64;
   probabilities: vec float64;
 };
type Forecast = vec float64;
type Follower = 
 record {
   createdAt: Time;
   user: text;
 };
type Followee = 
 record {
   createdAt: Time;
   user: text;
 };
type FeedItem = 
 variant {
   bet: Bet;
   comment: CommentStable;
   market: MarketStable;
   post: PostStable;
 };
type DepositAddr = 
 variant {
   btc: text;
   cycles: text;
   icp: text;
 };
type CommentStable = 
 record {
   author: UserData;
   content: text;
   createdAt: Time;
   id: nat32;
   likes: vec Like;
   modifiedAt: Time;
 };
type CollateralType = 
 variant {
   cycles;
   icp;
   seers;
 };
type BrierScore = 
 record {
   createdAt: Time;
   score: float64;
 };
type Bet = 
 record {
   comment: CommentStable;
   tx: UserTx;
 };
type Balance = 
 record {
   btc: float64;
   cycles: float64;
   icp: float64;
   seers: float64;
 };
type AccountIdentifier = blob;
service : () -> Market
