type UserTokens = 
 record {
   marketId: MarketId;
   noBalance: Balance;
   yesBalance: Balance;
 };
type UserShares = 
 record {
   marketId: MarketId;
   shares: Shares;
 };
type UserResult = 
 record {
   id: UserId;
   liquidityProviderFor: vec UserShares;
   marketTokens: vec UserTokens;
   seerBalance: Balance;
 };
type UserId = text;
type Title = text;
type Time = int;
type Shares = nat64;
type Probability = nat64;
type MarketResult = 
 record {
   author: Author;
   blockTimestampLast: Time;
   description: Description;
   endDate: Time;
   id: MarketId;
   kLast: Balance;
   liquidity: Balance;
   noProb: Probability;
   providers: vec text;
   reserveNo: Balance;
   reserveYes: Balance;
   startDate: Time;
   title: Title;
   totalShares: Shares;
   yesProb: Probability;
 };
type MarketInitData = 
 record {
   description: Description;
   endDate: Time;
   liquidity: Balance;
   noProb: Probability;
   title: Title;
   yesProb: Probability;
 };
type MarketId = nat32;
type Market = 
 service {
   addLiquidity: (MarketId, Balance) -> (bool);
   buyNo: (MarketId, Balance) -> (opt Balance);
   buyYes: (MarketId, Balance) -> (opt Balance);
   createMarket: (MarketInitData) -> (nat32);
   deleteAllMarkets: () -> ();
   deleteAllUsers: () -> ();
   deleteMarket: (MarketId) -> (bool);
   readAllMarkets: () -> (vec MarketResult) query;
   readAllUsers: () -> (vec UserResult) query;
   readMarket: (MarketId) -> (opt MarketResult) query;
   removeLiquidity: (MarketId) -> (bool);
   sellNo: (MarketId, Balance) -> (opt Balance);
   sellYes: (MarketId, Balance) -> (opt Balance);
   updateMarket: (MarketId, MarketResult) -> (bool);
 };
type Description = text;
type Balance = nat64;
type Author = text;
service : () -> Market
